(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{628:function(t,e,r){"use strict";r.r(e);var o=r(17),a=Object(o.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h3",{attrs:{id:""}},[r("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])]),t._v(" "),r("h3",{attrs:{id:"buffer-pool"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#buffer-pool"}},[t._v("#")]),t._v(" Buffer Pool")]),t._v(" "),r("p",[t._v("内存中的一块区域，默认大小为 128 MB，保存了 MySQL 查询和写入的数据信息，其分页淘汰机制是最近最少使用。")]),t._v(" "),r("p",[t._v("**free链表：**单链表结构，维护 Buffer Pool 中的空页信息。当分页被填满，从free链表中的头节点移除控制块信息；当分页被清空，将分页控制块信息添加到 free 链尾部。")]),t._v(" "),r("p",[r("strong",[t._v("flush链表：")]),t._v(" 单链表结构，维护 Buffer Pool 中的脏页信息。当分页数据被更新时，该分页会被标记为脏页，其分页控制块信息被添加到 flush 链表尾部。MySQL 会在后台运行一个线程每隔一段时间检查 Buffer Pool 中的分页是否为脏页，当分页被标记为脏页时，线程会将分页的数据进行持久化，并将其控制块信息从flush 链表中移除。")]),t._v(" "),r("p",[r("strong",[t._v("lru链表：")]),t._v(" lru链表是一个固定长度的链表，当分页被使用后其控制信息会被添加到队列头部，若其已在队列中则将被移至队列首部。当lru 链表超过一定长度范围后，会淘汰链表末尾分页信息。")]),t._v(" "),r("p",[t._v("为了避免 Buffer Pool 的分页全局刷新，lru 链表又被分为热数据区和冷数据区，当热数据区已满，其分页信息将插入到冷数据区的头部，若已存在于冷数据区，则将被移至冷数据区头部。当冷数据区的分页前后访问 t2-t1 >1s 时，该分页控制信息将被移至热数据头部。")]),t._v(" "),r("h3",{attrs:{id:"redo-log"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redo-log"}},[t._v("#")]),t._v(" Redo Log")]),t._v(" "),r("p",[t._v("MySQL 在安装时会默认创建两个大小为 48 MB 的 redo Log 文件： ib_logfile0 和ib_logfile1 ，记录了事务过程的每步操作信息，ib_logfile0 和 ib_logfile1 会交替进行写入。在交替写入过程中，若一个文件内容将被覆盖，MySQL 会触发 Check Point 对文件的事务操作进行持久化。")]),t._v(" "),r("p",[t._v("当服务器宕机重新启动后，MySQL 会首先加载 redo Log 文件，对未进行持久化的数据进行持久化。")]),t._v(" "),r("h3",{attrs:{id:"log-buffer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#log-buffer"}},[t._v("#")]),t._v(" Log Buffer")]),t._v(" "),r("p",[t._v("写操作时首先把事务过程保存到 Log Buffer 中，然后根据策略刷新到 redo log 中并进行持久化。")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",{staticStyle:{"text-align":"center"}},[t._v("配置值")]),t._v(" "),r("th",{staticStyle:{"text-align":"left"}},[t._v("描述")])])]),t._v(" "),r("tbody",[r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("0")]),t._v(" "),r("td",{staticStyle:{"text-align":"left"}},[t._v("事务提交不立即对 redo log 进行持久化，任务交给后台线程")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),r("td",{staticStyle:{"text-align":"left"}},[t._v("事务提交时，立即对 redo log 进行持久化")])]),t._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[t._v("2")]),t._v(" "),r("td",{staticStyle:{"text-align":"left"}},[t._v("事务提交时，立即将 redo log 写到操作系统缓冲区，然后定时将缓冲区事务写到 redo log 中。若出现数据库宕机，但操作系统正常，事务的持久性依然可以保持")])])])]),t._v(" "),r("h3",{attrs:{id:"bin-log-和-undo-log"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#bin-log-和-undo-log"}},[t._v("#")]),t._v(" Bin Log 和 Undo Log")]),t._v(" "),r("p",[t._v("Bin Log 记录了是主服务器进行 主从复制调用")]),t._v(" "),r("p",[t._v("Undo Log 是与 redo Log 相反的操作")]),t._v(" "),r("h3",{attrs:{id:"change-buffer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#change-buffer"}},[t._v("#")]),t._v(" Change Buffer")]),t._v(" "),r("p",[t._v("数据表的字段建立索引后，维护数据时需要同步维护索引，造成大量的 IO 操作。MySQL 在执行更新操作时，首先会更新数据，然后将更新操作记录到 Change Buffer 中。当 MySQL 进行查询操作时，首先会检查查询出的索引页索引是否存在于 Change Buffer 中，若存在，则更新当前索引。")])])}),[],!1,null,null,null);e.default=a.exports}}]);