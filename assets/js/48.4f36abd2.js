(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{598:function(t,s,a){"use strict";a.r(s);var n=a(17),v=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("高并发编程学习笔记，学习资源 ——《尚硅谷高级技术之 JUC 高并发编程》。")]),t._v(" "),a("p",[t._v("本篇笔记主要包括一下内容：")]),t._v(" "),a("ol",[a("li",[t._v("什么是 JUC，对 JUC 的定义进行了简要说明；")]),t._v(" "),a("li",[t._v("进程和线程的概念，是本篇笔记的重点内容，详细地介绍了进程与线程的相关概念。")])]),t._v(" "),a("h2",{attrs:{id:"什么是juc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是juc"}},[t._v("#")]),t._v(" 什么是JUC")]),t._v(" "),a("p",[t._v("JUC 是 java.util .concurrent 工具包的简称，是处理线程的工具包，从 Java1.5 开始出现。")]),t._v(" "),a("h2",{attrs:{id:"进程和线程的概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程的概念"}},[t._v("#")]),t._v(" 进程和线程的概念")]),t._v(" "),a("h3",{attrs:{id:"进程与线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程"}},[t._v("#")]),t._v(" 进程与线程")]),t._v(" "),a("p",[t._v("进程 ( process ) 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行"),a("strong",[t._v("资源分配和调度的基本单位")]),t._v("，是操作系统结构的基础。")]),t._v(" "),a("p",[t._v("线程 ( thread ) 是操作系统能够进行"),a("strong",[t._v("运算调度的最小单位")]),t._v("。它被包含在进程之中，是进程中的实际运作单位。")]),t._v(" "),a("h3",{attrs:{id:"进程状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程状态"}},[t._v("#")]),t._v(" 进程状态")]),t._v(" "),a("p",[t._v("线程枚举类：")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("enum")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("State")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n     "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//新建状态")]),t._v("\n     NEW"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n     "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//就绪状态")]),t._v("\n     RUNNABLE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n     "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//阻塞状态")]),t._v("\n     BLOCKED"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n     "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//等待状态")]),t._v("\n     WAITING"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n     "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//超时等待")]),t._v("\n     TIME_WAITING"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n     "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//终止状态")]),t._v("\n     TERMINATED"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br")])]),a("ul",[a("li",[a("strong",[t._v("NEW（新建）：")]),t._v(" 调用 new() 创建一个线程后，处于新建状态。此时该线程仅有 Java 虚拟机为其分配内存并初始化其成员变量，还没有表现出任何线程的动态特征。")]),t._v(" "),a("li",[a("strong",[t._v("RUNNABLE（就绪）：")]),t._v(" 当线程对象调用 start() 后，线程处于就绪状态。Java 虚拟机为其创建方法调用栈和程序计数器，等待JVM里的线程调度器调度。一旦获得 cup，则执行 run() 方法中的执行体。")]),t._v(" "),a("li",[a("strong",[t._v("BLOCKED（阻塞）：")]),t._v(" 线程执行过程中被中断，等待某个监视器锁的线程。当发生如下情况时，线程会进入阻塞状态：")])]),t._v(" "),a("blockquote",[a("ul",[a("li",[t._v("线程调用了 sleep() 方法主动放弃占用的cpu资源；")]),t._v(" "),a("li",[t._v("线程调用了一个阻塞式 IO 方法，在该方法返回之前，该线程被阻塞；")]),t._v(" "),a("li",[t._v("线程试图获取一个同步监视器，但该同步监视器正被其他线程使用；")]),t._v(" "),a("li",[t._v("线程正在等待某一个通知；")]),t._v(" "),a("li",[t._v("程序调用了线程 suspend() 方法将该线程挂起。该方法容易造成死锁，不推荐使用。")])])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("WAITING（等待）：")]),t._v(" 一个正在等待另一个线程执行的某一个操作的线程处于这一状态。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("TIME_WAITING（超时等待）：")]),t._v(" 一个正在限时等待另一个线程执行某一动作的线程处于这一状态。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("TERMINATED（终止）：")]),t._v(" 线程完成执行进入终止状态。")])])]),t._v(" "),a("p",[t._v("线程5种状态转换关系如下图所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://rdgmm6gnu.hn-bkt.clouddn.com/images/20211117185939.png",alt:"image-20211117185939653"}})]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"wait-sleep-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#wait-sleep-的区别"}},[t._v("#")]),t._v(" wait() / sleep() 的区别")]),t._v(" "),a("blockquote",[a("ul",[a("li",[t._v("sleep() 是 Thread 的静态方法，wait() 是 Object 的方法，任何对象实例都能调用。")]),t._v(" "),a("li",[t._v("sleep() 不会释放锁，它也不需要占用锁。而 wait() 会释放锁，并需要通过 notify() / notifyAll() 重新获取锁。")]),t._v(" "),a("li",[t._v("sleep() 可以在任何地方调用，而 wait() 只能在同步方法或同步代码块中调用。")])])]),t._v(" "),a("h3",{attrs:{id:"并发与并行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并发与并行"}},[t._v("#")]),t._v(" 并发与并行")]),t._v(" "),a("p",[a("strong",[t._v("串行模式：")]),t._v(" 串行表示所有任务都一一按先后顺序进行。串行是一次只能取得一个任务，并执行这个任务。")]),t._v(" "),a("p",[a("strong",[t._v("并行模式：")]),t._v(" 并行意味着可以同时取得多个任务，并同时去执行所取得的这些任务。并行的效率从代码层次上强依赖于多进程/多线程代码，从硬件角度上则依赖于多核 CPU。")]),t._v(" "),a("p",[a("strong",[t._v("并发：")]),t._v(" 并发 (concurrent) 指的是多个程序可以同时运行的现象，更细化的是多进程可以同时运行或者多指令可以同时运行。")]),t._v(" "),a("blockquote",[a("p",[t._v("并发：同一时刻多个线程在访问同一个资源，多个线程对一个点\n例子：春运抢票 电商秒杀...\n并行：多项工作一起执行，之后再汇总\n例子：泡方便面，电水壶烧水，一边撕调料倒入桶中")])]),t._v(" "),a("h3",{attrs:{id:"管程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#管程"}},[t._v("#")]),t._v(" 管程")]),t._v(" "),a("p",[a("strong",[t._v("管程 (monitor)")]),t._v(" 是保证了同一时刻只有一个进程在管程内活动,即管程内定义的操作在同一时刻只被一个进程调用 (由编译器实现)，但是这样并不能保证进程以设计的顺序执行。")]),t._v(" "),a("p",[t._v("JVM 中同步是基于进入和退出管程 (monitor) 对象实现的，每个对象都会有一个管程 (monitor) 对象，管程 (monitor) 会随着 java 对象一同创建和销毁。")]),t._v(" "),a("p",[t._v("执行线程首先要持有管程对象，然后才能执行方法，当方法完成之后会释放管程，方法在执行时候会持有管程，其他线程无法再获取同一个管程。")]),t._v(" "),a("h3",{attrs:{id:"用户线程和守护线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用户线程和守护线程"}},[t._v("#")]),t._v(" 用户线程和守护线程")]),t._v(" "),a("p",[a("strong",[t._v("用户线程：")]),t._v(" 平时用到的普通线程,自定义线程。")]),t._v(" "),a("p",[a("strong",[t._v("守护线程：")]),t._v(" 运行在后台,是一种特殊的线程,比如垃圾回收。")]),t._v(" "),a("p",[t._v("当主线程结束后,用户线程还在运行，JVM 存活。如果没有用户线程，都是守护线程，JVM 结束")]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://rdgmm6gnu.hn-bkt.clouddn.com/images/20211118170632.png",alt:""}})])])}),[],!1,null,null,null);s.default=v.exports}}]);